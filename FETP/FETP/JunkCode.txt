// public void addDay()

/*
// fills in days with blank timeslots
public void fillInDays()
{
List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

for (int i = 0; i < this.numberOfDays; i++)
{
    Day newDay = new Day(examsStartTime);
    TimeSpan examCurrentTime = this.examsStartTime;
    for (int j = 0; j < FETP_Controller.getNumberOfTimeSlotsAvailablePerDay(this); j++)
    {
        newDay.blocks.Add(new Timeslot(examCurrentTime, examCurrentTime + examsLength));
        // ? check if lunch and account for it here
        examCurrentTime += examsLength + timeBetweenExams;
    }
}
}
*/




/*
public Block(TimeSpan inStartTime, TimeSpan inEndTime, List<DayOfWeek> inDaysMeet, List<Class> inClasses = null)
    : base(inStartTime, inEndTime, inDaysMeet, )
{
    this.classesInBlock = inClasses;

    // calculate total enrollement
    foreach (Class clas in inClasses)
        this.enrollment += clas.Enrollment;

}
*/
//public Block(TimeSpan inStartTime, TimeSpan inEndTime, int inEnrollment, List<Class> inClasses)
//    : base(inStartTime, inEndTime, inEnrollment)
//{
//    if (inClasses == null)
//        this.classesInBlock = new List<Class>();
//    else
//        this.classesInBlock = inClasses;
//}






//public Block(Class inClass, List<Class> inClasses = null)
//    : base(inClass.StartTime, inClass.EndTime, 0)
//{
//    this.classesInBlock = inClasses;
//    addClass(inClass);
//}




// ? let's get dirty

public volatile int smallestGroupSizeFound;
public volatile List<List<Block>> smallestGroupsFound = new List<List<Block>>();



//// finds the smallest grouping
//public void groupClasses(List<Class> classes)
//{
//    List<Block> blocks = new List<Block>();
//    //groupingHelper(blocks, classes);
//    //helpMe(blocks, classes);
//    //Console.WriteLine("{0}", findSmallestGroup(blocks, classes));
//    Console.WriteLine("{0}", findNextSmallestGroup(blocks, classes, this.smallestGroupSizeFound));
//}









//// Recursive Helper
//protected List<Block> groupingHelper(List<Block> blocks, List<Class> classes)
//{

//    if (classes.Count == 0)
//    {
//        return blocks;
//    }
//    else
//    {
//        //List<Block> newBlocks = blocks;

//        foreach (Class cl in classes)
//        {
//            blocks = groupClass(blocks, cl);
//        }

//        if (blocks.Count <= this.smallestGroupSizeFound)
//        {
//            this.smallestGroupSizeFound = blocks.Count;
//            this.smallestGroupsFound.Add(blocks);
//        }

//        foreach (Class cl in classes)
//        {
//            List<Block> newBlocks = blocks;
//            List<Class> newClasses = classes;
//            newClasses.Remove(cl);
//            newBlocks = groupClass(newBlocks, cl);

//            newBlocks = groupingHelper(newBlocks, classes);
//            if(newBlocks.Count < this.smallestGroupSizeFound)
//            {
//                this.smallestGroupSizeFound = newBlocks.Count;
//            }
//        }
//        return groupingHelper
//    }
//}

//public static async Task findSmallest(List<Block>Blocks, List<Class> classes, int smallestThusFar)
//{

//}

//public List<Thread> threads = new List<Thread>();

//// Recursive Helper
//// simulates all possible groups and only saves the smallest
//protected void groupingHelper(List<Block> blocks, List<Class> classes, int smallestThusFar)
//{

//    if (classes.Count != 0 && blocks.Count < smallestThusFar)
//    {
//        //List<Block> newBlocks = blocks;
//        int i = 0;
//        while (i < classes.Count)
//        {
//            List<Block> newBlocks = new List<Block>(this.groupClass(blocks, classes[i]));
//            List<Class> newClasses = new List<Class>(classes);
//            newClasses.RemoveAt(i);

//            thread.Add(new Thread((groupingHelper(newBlocks, newClasses, smallestThusFar));

//            i++;
//        }


//        //foreach (Class cl in classes)
//        //{
//        //    List<Block> newBlocks = this.groupClass(blocks, cl);
//        //    List<Class> newClasses = classes;
//        //    Console.WriteLine("removing class");
//        //    newClasses.Remove(cl);
//        //    Console.WriteLine("removed class");
//        //    groupingHelper(newBlocks, newClasses);

//        //}
//    }
//    else if (blocks.Count <= this.smallestGroupSizeFound)
//    {
//        this.smallestGroupsFound.Add(blocks);
//    }
//}




//public async Task<> helpMe(List<Block> blocks, List<Class> classes)
//{
//    await groupingHelper(blocks, classes);
//}


// Recursive Helper
// simulates all possible groups and only saves the smallest
//protected async void groupingHelper(List<Block> blocks, List<Class> classes)
//{

//    if (classes.Count != 0 && blocks.Count < this.smallestGroupSizeFound)
//    {
//        //List<Block> newBlocks = blocks;
//        int i = 0;
//        while (i < classes.Count)
//        {
//            List<Block> newBlocks = new List<Block>(Schedule.groupClass(blocks, classes[i]));
//            List<Class> newClasses = new List<Class>(classes);
//            newClasses.RemoveAt(i);

//            groupingHelper(newBlocks, newClasses);

//            i++;
//        }


//        //foreach (Class cl in classes)
//        //{
//        //    List<Block> newBlocks = this.groupClass(blocks, cl);
//        //    List<Class> newClasses = classes;
//        //    Console.WriteLine("removing class");
//        //    newClasses.Remove(cl);
//        //    Console.WriteLine("removed class");
//        //    groupingHelper(newBlocks, newClasses);

//        //}
//    }
//    else if (blocks.Count <= this.smallestGroupSizeFound)
//    {
//        this.smallestGroupsFound.Add(blocks);
//    }
//}


//protected static async void findSmallgroup(List<Block> blocks, List<Class> classes)
//{
//    int currentSmallest;
//    List<Block> newBlocks = new List<Block>(blocks);
//    foreach (Class cl in classes)
//    {
//        newBlocks = groupClass(newBlocks, cl);
//    }

//    currentSmallest = newBlocks.Count;

//    foreach (Class cl in classes)
//    {
//        List<Class> newClasses = new List<Class>(classes); // ?
//        newClasses.RemoveAt(i);
//        int number = findSmallestGroup(groupClass((new List<Block>(blocks)), classes[i]), newClasses);
//        if (number < currentSmallest)
//        {
//            currentSmallest = number;
//        }
//    }

//    Console.WriteLine("Current smallest: {0}", currentSmallest);


//}

//// ? make task 
//protected static async Task<int> findSmallestGroup(List<Block> blocks, List<Class> classes)
//{
//    if (classes.Count == 0)
//    {

//        return blocks.Count;

//    }
//    else
//    {
//        List<Block> newBlocks = new List<Block>(blocks);
//        foreach (Class cl in classes)
//        {
//            newBlocks = groupClass(newBlocks, cl);
//        }

//        int currentSmallest = newBlocks.Count;

//        int i = 0;
//        while (i < classes.Count)
//        {

//            List<Class> newClasses = new List<Class>(classes); // ?
//            newClasses.RemoveAt(i);
//            int number = findSmallestGroup(groupClass((new List<Block>(blocks)), classes[i]), newClasses);
//            if (number < currentSmallest)
//            {
//                currentSmallest = number;
//            }

//        }
//        return currentSmallest;
//    }
//}

//protected int numberOfExecutions = 0;
//protected int findNextSmallestGroup(List<Block> blocks, List<Class> classes, int currentSmallest)
//{
//    Console.WriteLine(numberOfExecutions++);
//    if (blocks.Count > currentSmallest)
//    {
//        return currentSmallest;
//    }
//    else if (classes.Count == 0) // count must be smaller or equal to smallest thus far
//    {
//        return blocks.Count;
//    }
//    else
//    {

//        List<Block> newBlocks = new List<Block>(blocks);

//        //Stopwatch stopWatch = new Stopwatch();
//        //stopWatch.Start();
//        foreach (Class cl in classes)
//        {
//            newBlocks = groupClass(newBlocks, cl);
//        }

//        //stopWatch.Stop();
//        //Console.WriteLine(stopWatch.Elapsed);
//        if (blocks.Count < currentSmallest)
//        {
//            return blocks.Count;
//        }
//        //else
//        //{
//        Parallel.ForEach(classes, (cl) =>
//            {
//                // newBlocks = groupClass(newBlocks, classes[i]);
//                List<Class> newClasses = new List<Class>(classes); // ?
//                newClasses = removeClass(newClasses, cl);
//                int number = findNextSmallestGroup(groupClass((new List<Block>(blocks)), cl), newClasses, currentSmallest);
//                if (number < currentSmallest)
//                {
//                    // currentSmallest = number;
//                    currentSmallest = number;
//                    return;
//                }

//            });
//            return currentSmallest;
//        }





//        return currentSmallest;

//        //    foreach(Class cl in classes)
//        //{
//        //    // newBlocks = groupClass(newBlocks, classes[i]);
//        //    List<Class> newClasses = new List<Class>(classes); // ?
//        //    removeClass(newClasses, cl);
//        //    int number = findNextSmallestGroup(groupClass((new List<Block>(blocks)), cl), newClasses, currentSmallest);
//        //    if (number < currentSmallest)
//        //    {
//        //        // currentSmallest = number;
//        //        return number;
//        //    }
//        //}

//        //int i = 0;
//        //while (i < classes.Count)
//        //{
//        //    // newBlocks = groupClass(newBlocks, classes[i]);
//        //    List<Class> newClasses = new List<Class>(classes); // ?
//        //    newClasses.RemoveAt(i);
//        //    int number = findNextSmallestGroup(groupClass((new List<Block>(blocks)), classes[i]), newClasses, currentSmallest);
//        //    if (number < currentSmallest)
//        //    {
//        //        // currentSmallest = number;
//        //        return number;
//        //    }

//        //}


//    //}
//}




//// ? make task 
//protected static int findSmallestGroup(List<Block> blocks, List<Class> classes)
//{
//    if(classes.Count == 0)
//    {

//        return blocks.Count;

//    } 
//    else
//    {
//        List<Block> newBlocks = new List<Block>(blocks);
//        foreach(Class cl in classes)
//        {
//            newBlocks = groupClass(newBlocks, cl);
//        }

//        int currentSmallest = newBlocks.Count;

//        int i = 0;
//        while (i < classes.Count)
//        {

//            List<Class> newClasses = new List<Class>(classes); // ?
//            newClasses.RemoveAt(i);
//            int number = findSmallestGroup(groupClass((new List<Block>(blocks)), classes[i]), newClasses);
//            if(number < currentSmallest)
//            {
//                currentSmallest = number;
//            }

//        }
//        return currentSmallest;
//    }
//}


//protected List<Block> checkAllPossibleGroups(List<Block> blocks, List<Class> classes)
//{

//}


//protected void helpMe(List<Block> blocks, List<Class> classes)
//{
//    if(classes.Count == 0)
//    {
//        if(blocks.Count < this.smallestGroupSizeFound)
//        {
//            this.smallestGroupSizeFound = blocks.Count;
//        }
//    }
//    else
//    {
//        //List <Block> newBlocks = new List<Block>(blocks);
//        //foreach(Class cl in classes)
//        //{
//        //    groupClass(newBlocks, cl);
//        //}
//        //if(newBlocks.Count < this.smallestGroupSizeFound)
//        //{
//        //    this.smallestGroupSizeFound = newBlocks.Count;
//        //}
//        //List<Block> newBlocks = blocks;

//        int i = 0;
//        while (i < classes.Count)
//        {
//            List<Class> what = new List<Class>(classes); // ?
//            what.RemoveAt(i);
//            helpMe(groupClass((new List<Block>(blocks)),classes[i]), what);
//        }
//    }
//}













//// playing with TimeSlot class
////hmmmm
//// ? did i really just make this?
//// it's LITERALLY just a block... damn
//public class Timeslot : Class
//{
//    protected Block groupOfClasses;

//    public Timeslot(TimeSpan inStartTime, TimeSpan inEndTime, Block inBlock = null, List<DayOfWeek> inDaysMeet = null, int inEnrollment = 0)
//        : base(inStartTime, inEndTime, inDaysMeet, inEnrollment)
//    {
//        this.groupOfClasses = inBlock;
//    }



//    public override void Display()
//    {
//        base.Display();
//    }

//}

// ? oh gawd this hurts. why ben? why? why did you do this? it's not good
//public class Day
//{
//    public List<Block> blocks; // ? lazy
//    protected TimeSpan dayStartTime;
//    protected TimeSpan lunchStartTime;
//    protected TimeSpan lunchEndTime;


//    public Day(TimeSpan dayStartTime, TimeSpan lunchStartTime = TimeSpan.Zero, TimeSpan lunchEndTime = TimeSpan.Zero, List<Block> inBlocks = null) // 0 because there won't always be lunch
//    {
//        this.dayStartTime = dayStartTime;
//        this.lunchStartTime = lunchStartTime;
//        this.lunchEndTime = lunchEndTime;
//        this.blocks = inBlocks;
//    }



//    public void Display()
//    {
//        foreach (Timeslot block in blocks)
//            block.Display();
//    }
//}




//// checks if class overlaps with any class in a block
//public static bool doesClassOverlapBlock(Block block, Class inClass)
//{
//    foreach (Class cl in block.ClassesInBlock)
//    {
//        if (!doClassesOverlap(cl, inClass))
//        {
//            return false;
//        }
//    }
//    return true;
//}

// Helper function to find the total days two classes have in common.



//// ? maybe correct?
//public static int getSmallestPossibleGrouping(List<Class> classes)
//{
//    return (coalesceClassesTogether(sortClassesByOverlappingDays(classes))).Count;
//}

// Find if any classes overlap in list of classes


//// Checks if enough timeslots are available
//public static bool areThereEnoughTimeslots(Schedule schedule, List<Class> classes)
//{
//    return (getNumberOfTimeSlotsAvailable(schedule) >= getSmallestPossibleGrouping(classes));
//}

/*
// ? in theory, this will automatically find what days a block meets.
// a block should only meet on MWF or TR
//return a key value
//      Day: #
//      Number of those days: #
public static List<DayOfWeek> getMostCommonDays(List<Class> classes)
{
    foreach (Class class1 in classes)
    {
        foreach (Class class2 in classes)
        {
            if (doClassDaysOverlap(class1, class2))
                return true;
        }
    }
    return false;
}
*/


//public static TimeSpan putInClosestPossibleBlock()
//{
//    // first look for closest block with start time, then go to next largest

//        // preference to being later then earlier


//}
// takes in a list of classes 
// returns a new list of groups of classes
// can be used to find a grouping size to beat

// ? original
//// takes in a list of classes and coalesces them into a list of blocks of classes
//public static List<Block> coalesceClassesTogether(List<Class> classes)
//{
//    List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

//    foreach (Class cl in classes)
//    {
//        bool doesItOverlap = false;
//        foreach(Block block in classesToBeGrouped)
//        {
//            if (doClassesOverlap(cl, block.ClassesInBlock[0])) // ? changed to 0. makes no difference when making smallest classes, but should make it work with blank days
//            {
//                block.addClass(cl);
//                doesItOverlap = true;
//                break; // ?bug THIS WASN'T THERE :'( // maybe not a bug due to ordering?
//            }
//        }
//        if(!doesItOverlap)
//            classesToBeGrouped.Add(new Block(cl));
//    }
//    return classesToBeGrouped;

//}

// takes in a list of classes and coalesces them into a list of blocks of classes




//// takes in a list of classes and coalesces them into a list of blocks of classes
//public static List<Block> coalesceClassesTogether(List<Class> classes, List<Block> groups)
//{
//    // ? check if possible maybe?
//    //

//    if (groups == null)
//    {
//        groups = new List<Block>(); // Variable to contain the list of all grouped classes
//    }

//    foreach (Class cl in classes)
//    {
//        bool isFound = false;

//        TimeSpan weight = TimeSpan.Zero;
//        while (!isFound) // ?hello infinity
//        {

//            foreach (Block block in groups)
//            {
//                if (block.StartTime - cl.StartTime < weight && (block.ClassesInBlock == null || doClassesOverlap(cl, block.ClassesInBlock[0]))) // could reference null, but should drop out
//                {
//                    block.addClass(cl);
//                    isFound = true;
//                    break; // ? BAD BAD BAD :'(
//                }
//            }
//            weight += TimeSpan.FromMinutes(30);
//        }

//    }
//    return groups;
//}

//public static getClosest

//// ? need to rewrite and combine these
//// takes in a list of classes and coalesces them into a list of blocks of classes
//public static List<Block> coalesceClassesTogether(List<Class> classes)
//{
//    List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

//    // ? oh gawd this hurts
//    List<Block> allGroups = new List<Block>;

//    foreach (Class cl in classes)
//    {
//        bool doesItOverlap = false;
//        foreach (Block block in classesToBeGrouped)
//        {
//            if (doClassesOverlap(cl, block.ClassesInBlock[0])) // ? changed to 0. makes no difference when making smallest classes, but should make it work with blank days
//            {
//                block.addClass(cl);
//                doesItOverlap = true;
//            }
//        }
//        if (!doesItOverlap)
//            classesToBeGrouped.Add(new Block(cl));
//    }
//    return classesToBeGrouped;

//}


//public static List<Day> coalesceClassesIntoDays(Schedule schedule, List<Class> classes)
//{
//    //List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

//    //for(int i = 0; i < schedule.NumberOfDays; i++)
//    //{
//    //    Day newDay = new Day();
//    //    TimeSpan examCurrentTime = schedule.ExamsStartTime;
//    //    for(int j = 0; j < getNumberOfTimeSlotsAvailablePerDay(schedule); j++)
//    //    {
//    //        Block newBlock
//    //    }
//    //}

//    //return classesToBeGrouped;

//     List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

//     foreach (Class cl in classes)
//     {
//         bool doesItOverlap = false;
//         foreach (Day day in schedule.days)
//         {
//             foreach (day )
//             if (doClassesOverlap(cl, day.block))
//             {
//                 block.addClass(cl);
//                 doesItOverlap = true;
//             }
//         }
//         if (!doesItOverlap)
//             classesToBeGrouped.Add(new Block(cl));
//     }
//     return classesToBeGrouped;


// }



//// fills in days with blank timeslots
//public static List<Block> createShellDays(Schedule schedule)
//{
//    // List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

//    List<Block> groups = new List<Block>();

//    for (int i = 0; i < schedule.NumberOfDays; i++)
//    {
//        TimeSpan examCurrentTime = schedule.ExamsStartTime;
//        for (int j = 0; j < FETP_Controller.getNumberOfTimeSlotsAvailablePerDay(schedule); j++)
//        {
//            groups.Add(new Block(examCurrentTime, examCurrentTime + schedule.ExamsLength));
//            // ? check if lunch and account for it here
//            examCurrentTime += schedule.ExamsLength + schedule.TimeBetweenExams;
//        }
//    }

//    return groups;
//}
/*
// fills in days with blank timeslots
public List<Days> createShellDays(int numberOfDays, int numberOfTimeslotsPerDay, int examsStartTime, TimeSpan examsLength, TimeSpan timeBetweenExams)
{
    List<Block> classesToBeGrouped = new List<Block>(); // Variable to contain the list of all grouped classes

    for (int i = 0; i < this.numberOfDays; i++)
    {
        Day newDay = new Day(examsStartTime);
        TimeSpan examCurrentTime = this.examsStartTime;
        for (int j = 0; j < FETP_Controller.getNumberOfTimeSlotsAvailablePerDay(this); j++)
        {
            newDay.blocks.Add(new Timeslot(examCurrentTime, examCurrentTime + examsLength));
            // ? check if lunch and account for it here
            examCurrentTime += examsLength + timeBetweenExams;
        }
    }
}
*/


/*
// ? switching up style of functions here to make coupling ?lower?
public static List<Days> makeBlankDays(TimeSpan startTime, TimeSpan endTime, TimeSpan examLength)
*/


//Console.WriteLine("4. Test Advanced Grouping (not ready)");
//Console.WriteLine("5. Test Advanced Advanced Grouping (not ready)");

//else if (input == "4")
//{
//    Console.WriteLine(STARS);
//    Console.WriteLine("Testing Advanced Grouping of Classes");
//    Console.WriteLine(STARS);

//    // ------------------------------------------------------------------------------------------------------
//    // Get data file information
//    FileStream inFile = File.OpenRead(@"../../../../Example Data/Spring 2015 Total Enrollments by Meeting times.csv");

//    // currently sorts all the data
//    List<Class> allClasses = FETP_Controller.readInputDataFile(inFile);
//    // ------------------------------------------------------------------------------------------------------

//    // ------------------------------------------------------------------------------------------------------
//    // Get contraints file information
//    inFile = File.OpenRead(@"../../../../Example Data/Ben Made Constraints Sample.txt");
//    // List<Class> allClasses = FETP_Controller.sortClassesByEnrollment(FETP_Controller.readInputDataFile(inFile));
//    Schedule blankSchedule = FETP_Controller.readInputConstraintsFile(inFile);
//    // ------------------------------------------------------------------------------------------------------


//    allClasses = FETP_Controller.sortClassesByEnrollment(allClasses);
//    List<Block> groupedClasses = FETP_Controller.coalesceClassesTogether(allClasses);


//    Console.WriteLine("Number of Blocks: {0}", groupedClasses.Count);
//    Console.WriteLine();

//    foreach (Block block in groupedClasses)
//    {
//        Console.WriteLine("=================================");
//        Console.WriteLine("Displaying Block");
//        Console.WriteLine("=================================");

//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("Displaying Information of Block");
//        Console.WriteLine("---------------------------------");

//        block.Display();
//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("END Displaying Information of Block");
//        Console.WriteLine("---------------------------------");


//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("Displaying all Classes in Block");
//        Console.WriteLine("---------------------------------");
//        block.DisplayAllClasses();
//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("END Displaying all Classes in Block");
//        Console.WriteLine("---------------------------------");
//        Console.WriteLine();

//        Console.WriteLine("=================================");
//        Console.WriteLine("END Displaying Block");
//        Console.WriteLine("=================================");
//    }

//    Console.WriteLine(STARS);
//    Console.WriteLine("END Testing Advanced Grouping of Classes");
//    Console.WriteLine(STARS);

//}
//else if(input == "5")
//{
//    Console.WriteLine(STARS);
//    Console.WriteLine("Testing Advanced Advanced Grouping of Classes");
//    Console.WriteLine(STARS);

//    // ------------------------------------------------------------------------------------------------------
//    // Get data file information
//    FileStream inFile = File.OpenRead(@"../../../../Example Data/Spring 2015 Total Enrollments by Meeting times.csv");

//    // currently sorts all the data
//    List<Class> allClasses = FETP_Controller.readInputDataFile(inFile);
//    // ------------------------------------------------------------------------------------------------------

//    // ------------------------------------------------------------------------------------------------------
//    // Get contraints file information
//    inFile = File.OpenRead(@"../../../../Example Data/Ben Made Constraints Sample.txt");
//    // List<Class> allClasses = FETP_Controller.sortClassesByEnrollment(FETP_Controller.readInputDataFile(inFile));
//    Schedule blankSchedule = FETP_Controller.readInputConstraintsFile(inFile);
//    // ------------------------------------------------------------------------------------------------------


//    allClasses = FETP_Controller.sortClassesByOverlappingDays(allClasses);

//    //blankSchedule.blocks = FETP_Controller.createShellDays(blankSchedule);

//    List<Block> groupedClasses = Schedule.coalesceClassesTogether(allClasses);

//    blankSchedule.smallestGroupSizeFound = groupedClasses.Count;

//    Console.WriteLine("Smallest Group Found First: {0}", blankSchedule.smallestGroupSizeFound);

//    blankSchedule.groupClasses(allClasses);

//    Console.WriteLine("New Smallest Group Found: {0}", blankSchedule.smallestGroupSizeFound);







//foreach (Block block in groupedClasses)
//{
//    Console.WriteLine("=================================");
//    Console.WriteLine("Displaying Block");
//    Console.WriteLine("=================================");

//    Console.WriteLine("---------------------------------");
//    Console.WriteLine("Displaying Information of Block");
//    Console.WriteLine("---------------------------------");

//    block.Display();
//    Console.WriteLine("---------------------------------");
//    Console.WriteLine("END Displaying Information of Block");
//    Console.WriteLine("---------------------------------");


//    Console.WriteLine("---------------------------------");
//    Console.WriteLine("Displaying all Classes in Block");
//    Console.WriteLine("---------------------------------");
//    block.DisplayAllClasses();
//    Console.WriteLine("---------------------------------");
//    Console.WriteLine("END Displaying all Classes in Block");
//    Console.WriteLine("---------------------------------");
//    Console.WriteLine();

//    Console.WriteLine("=================================");
//    Console.WriteLine("END Displaying Block");
//    Console.WriteLine("=================================");
//}

//Console.WriteLine("Number of Blocks: {0}", groupedClasses.Count);
//Console.WriteLine();
//}













// Prototype function for example of how to sort
public static List<Class> sortClassesByEnrollment(List<Class> classes)
{
    return classes.OrderByDescending(c => c.Enrollment).ToList();
}

// Prototype function for example of how to sort
public static List<Class> sortClassesByOverlappingDays(List<Class> classes)
{
    return classes.OrderByDescending(c => getNumberOfOverlappingDays(classes, c)).ToList();
}



/**************************************************************************\
        Method: getNumberOfTimeSlotsAvailablep
        Description: 
        \**************************************************************************/
public static int getNumberOfTimeSlotsAvailable(Schedule schedule)
{
    return getNumberOfTimeSlotsAvailablePerDay(schedule) * schedule.NumberOfDays;
}


/**************************************************************************\
Method:  
Description: 
\**************************************************************************/
public static int getNumberOfTimeSlotsAvailablePerDay(Schedule schedule)
{
    TimeSpan latestTime = TimeSpan.ParseExact(TIME_EXAMS_MUST_END_BY, @"hhmm", CultureInfo.InvariantCulture); // latest exams can go

    TimeSpan lengthOfExamDay = latestTime - schedule.ExamsStartTime; // Figure out how much time available for exams

    // if the lunch time is longer than the break time, account for it and the extra break time it will give you
    if (schedule.LunchLength > schedule.TimeBetweenExams)
    {
        lengthOfExamDay -= (schedule.LunchLength - schedule.TimeBetweenExams); // takes the lunch break out of available time. also pads for how the lunch will count as a break.
    }


    TimeSpan examFootprint = schedule.ExamsLength + schedule.TimeBetweenExams;

    int numberOfExams = 0;
    // ? bug if exam break is too big
    while ((lengthOfExamDay - schedule.ExamsLength) >= TimeSpan.Zero)
    {
        lengthOfExamDay -= schedule.ExamsLength;
        numberOfExams++;

        // checks if a break is needed due to their being room for another exam after a break
        if ((lengthOfExamDay - (schedule.TimeBetweenExams + schedule.ExamsLength) >= TimeSpan.Zero))
        {
            lengthOfExamDay -= schedule.TimeBetweenExams;
        }
    }
    return numberOfExams;
}


// while (i < blocks.Count && !(isInserted = blocks[i++].addClass(inClass))) ; // ? i <3 my while loops that terminate in a semicolen


// ? i don't think i'll ever need this 
/**************************************************************************\
Method:  
Description: 
\**************************************************************************/
//public Schedule(Schedule inSchedule = null, List<Block> inBlocks = null)
//{
//    if (inSchedule != null)
//    {
//        this.numberOfDays = inSchedule.NumberOfDays;
//        this.examsStartTime = inSchedule.ExamsStartTime;
//        this.examsLength = inSchedule.ExamsStartTime;
//        this.timeBetweenExams = inSchedule.TimeBetweenExams;
//        this.lunchLength = inSchedule.LunchLength;
//    }
//    // ? could assign inSchedules days to it
//    this.blocks = inBlocks;
//}


class Generation
{
    private List<Schedule> schedules;

    public const int GENERATION_SIZE = 100; // ? big generations take a long time
    public const int NUMBER_OF_GENERATIONS = 4;

    private Stopwatch stopWatch = new Stopwatch();

    public List<Schedule> Schedules
    {
        get
        {
            return schedules;
        }
    }

    // create seed generation
    public Generation()
    {
        this.schedules = new List<Schedule>(Generation.GENERATION_SIZE);
        for (int i = 0; i < Generation.GENERATION_SIZE; i++)
        {
            this.schedules.Add(new Schedule());
        }
    }

    // creates next generation
    public Generation(List<Schedule> currentGeneration)
    {
        this.schedules = new List<Schedule>(Generation.GENERATION_SIZE);
        while (currentGeneration.Count > 0) // loop while there are still members in current generation // ? could optimze with just MAX_Generation and minus 2 but this is more scalable and reusable
        {
            // ? not sure if you're supposed to give the parents a chance to reproduce or not.
            // ? that should be handled just by selection?

            // get next two parents // separate out into antoher function??
            int indexOfParent1 = BenRoutlette(currentGeneration);
            int indexOfParent2 = BenRoutlette(currentGeneration);
            while (indexOfParent1 == indexOfParent2) // makes sure we have two different indexes
            {
                indexOfParent2 = BenRoutlette(currentGeneration);
            }



            // Add the two parents new children to the next generation
            this.schedules.Add(new Schedule(currentGeneration[indexOfParent1], currentGeneration[indexOfParent2]));
            this.schedules.Add(new Schedule(currentGeneration[indexOfParent2], currentGeneration[indexOfParent1]));

            // Remove the parents from the current pool
            if (indexOfParent1 > indexOfParent2) // this is to make sure removing one parent doesn't move the index of the second
            {
                currentGeneration.RemoveAt(indexOfParent1);
                currentGeneration.RemoveAt(indexOfParent2);
            }
            else
            {
                currentGeneration.RemoveAt(indexOfParent2);
                currentGeneration.RemoveAt(indexOfParent1);
            }
        }


    }


    // ? need to weight somewhere by one to avoid divide by zero if perfect population?
    /**************************************************************************\
    Method: BenRoutlette
    Description: Randomly selects an index with weight from fitness scores
    \**************************************************************************/
    public int BenRoutlette(List<Schedule> currentGeneration)
    {
        int totalFitnessScoreWeight = (ComputeTotalFitnessScore(currentGeneration)); // maybe add in one ? it avoids divide by zero

        double randomFloat = GetRandomFloat() * totalFitnessScoreWeight;

        for (int i = 0; i < currentGeneration.Count; i++) // ? current generation will shrink as more and more are moved to next generation 
        {
            randomFloat -= currentGeneration[i].FitnessScore;
            if (randomFloat <= 0)
            {
                return i;
            }
        }
        return currentGeneration.Count - 1; // ? This point should never be reached. roundoff error?
    }

    /**************************************************************************\
    Method: GetRandomFlot
    Description: Retrieves a random float between 0 and 1
    \**************************************************************************/
    public static double GetRandomFloat()
    {
        return new Random().NextDouble(); // ? we need a better implementation. numbers from this class are known to not be that random
    }

    public int ComputeTotalFitnessScore(List<Schedule> currentGeneration)
    {
        int totalFitnessScore = 0;
        foreach (Schedule schedule in currentGeneration)
        {
            totalFitnessScore += schedule.FitnessScore;
        }
        return totalFitnessScore;
    }
}



//else if (input == "3")
//{
//    Console.WriteLine(STARS);
//    Console.WriteLine("Testing Grouping of Classes");
//    Console.WriteLine(STARS);

//    // FileStream inFile = File.OpenRead(@"../../../../Example Data/Spring 2015 Total Enrollments by Meeting times.csv");

//    // currently sorts all the data
//    List<Class> allClasses = FETP_Controller.readInputDataFile("../../../../Example Data/Spring 2015 Total Enrollments by Meeting times.csv");
//    allClasses.OrderByDescending(c => c.Enrollment);
//    //allClasses = FETP_Controller.sortClassesByOverlappingDays(allClasses); // sort classes how you want 
//    List<Block> groupedClasses = FETP_Controller.coalesceClassesTogether(allClasses);


//    Console.WriteLine("Number of Blocks: {0}", groupedClasses.Count);
//    Console.WriteLine();

//    foreach (Block block in groupedClasses)
//    {
//        Console.WriteLine("=================================");
//        Console.WriteLine("Displaying Block");
//        Console.WriteLine("=================================");

//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("Displaying Information of Block");
//        Console.WriteLine("---------------------------------");

//        block.Display();
//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("END Displaying Information of Block");
//        Console.WriteLine("---------------------------------");


//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("Displaying all Classes in Block");
//        Console.WriteLine("---------------------------------");
//        block.DisplayAllClasses();
//        Console.WriteLine("---------------------------------");
//        Console.WriteLine("END Displaying all Classes in Block");
//        Console.WriteLine("---------------------------------");
//        Console.WriteLine();

//        Console.WriteLine("=================================");
//        Console.WriteLine("END Displaying Block");
//        Console.WriteLine("=================================");
//    }


//    Console.WriteLine(STARS);
//    Console.WriteLine("END Testing Grouping of Classes");
//    Console.WriteLine(STARS);
//}

    else if (input == "5") // GA 
                {
                    //Generation currentGeneration = new Generation();
                    //Stopwatch stopwatch = new Stopwatch();
                    //for (int i = 0; i < Generation.NUMBER_OF_GENERATIONS; i++)
                    //{
                    //    stopwatch.Start();
                    //    currentGeneration = new Generation(currentGeneration.Schedules);
                    //    stopwatch.Stop();
                    //    Console.WriteLine("Time to Execute {0} generations: {1}", i + 1, stopwatch.Elapsed);
                    //}
                }

    
                //Console.WriteLine("3. Test Basic Grouping");
                
                Console.WriteLine("5. Test Basic GA with Generation class (broken hard)");



    // creates next gen
        public Generation(Generation generation)
{
    // List<Schedule> nextGeneration = new List<Schedule>(GA_Controller.SIZE_OF_GENERATION);

    this.schedules = new List<Schedule>(Generation.SIZE_OF_GENERATION);
    List<Schedule> currentGeneration = new List<Schedule>(generation.Schedules); // ? a little confusing since currentGeneration isn't a generation object
    while (currentGeneration.Count > 0) // loop while there are still members in current generation // ? could optimze with just SIZE_OF_GENERATION and minus 2 but this is more scalable and reusable
    {
        // ? not sure if you're supposed to give the parents a chance to reproduce or not.
        // ? that should be handled just by selection?

        // get next two parents // separate out into antoher function??
        int indexOfParent1 = this.BenRoutlette(currentGeneration);
        int indexOfParent2 = this.BenRoutlette(currentGeneration);

        while (indexOfParent1 == indexOfParent2) // makes sure we have two different indexes
        {
            indexOfParent2 = this.BenRoutlette(currentGeneration);
        }


        // If parents are going to breed, pass their chidlren on to next generation, else pass parents on to next generation
        if (GA_Controller.WillParentsBreed(indexOfParent1, indexOfParent2))
        {
            // Add the two parents new children to the next generation
            this.schedules.Add(new Schedule(currentGeneration[indexOfParent1], currentGeneration[indexOfParent2]));
            this.schedules.Add(new Schedule(currentGeneration[indexOfParent2], currentGeneration[indexOfParent1]));
        }
        else
        {
            this.schedules.Add(currentGeneration[indexOfParent1]);
            this.schedules.Add(currentGeneration[indexOfParent2]);
        }

        // Remove the parents from the current pool
        if (indexOfParent1 > indexOfParent2) // this is to make sure removing one parent doesn't move the index of the second
        {
            currentGeneration.RemoveAt(indexOfParent1);
            currentGeneration.RemoveAt(indexOfParent2);
        }
        else
        {
            currentGeneration.RemoveAt(indexOfParent2);
            currentGeneration.RemoveAt(indexOfParent1);
        }

    }

    //currentGeneration = nextGeneration; // Advance to the next generation
}

public Generation(List<Schedule> inSchedules)
{
    this.schedules = inSchedules;
}

public bool IsEmpty()
{
    return this.schedules.Count <= 0;
}

 public Generation()
        {
            // Intialize the current generation
            // this.schedules = new List<Schedule>(Generation.SIZE_OF_GENERATION);
            this.schedules = new List<Schedule>(Generation.SIZE_OF_GENERATION);
            // create seed generation
            for (int i = 0; i < Generation.SIZE_OF_GENERATION; i++)
            {
                this.schedules.Add(new Schedule());
            }
        }







		using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
namespace FETP
{
    class Generation
    {
        private List<Schedule> schedules; // = new List<Schedule>(Generation.SIZE_OF_GENERATION);
        private double totalFitnessScore; 

        public List<Schedule> Schedules
        {
            get
            {
                return this.schedules;
            }
        }

        public const int SIZE_OF_GENERATION = 50; // ? big generations take a long time ? should be divisable by 2 ? we could write it to take a random number of parents for better crossover
        public const int NUMBER_OF_GENERATIONS = 100;
        public const int BEN_ALL_STAR_THREAD_LIMIT = 12;

        //private const float CROSSOVER_RATE = 0.7F;
        //public const float MUTATION_RATE = 0.15F;

        // creates seed generation
        public Generation()
        {
            // Intialize the current generation
            // this.schedules = new List<Schedule>(Generation.SIZE_OF_GENERATION);
            this.schedules = new List<Schedule>(Generation.SIZE_OF_GENERATION);
            // create seed generation
            for (int i = 0; i < Generation.SIZE_OF_GENERATION; i++)
            {
                this.schedules.Add(new Schedule());
            }
            //this.totalFitnessScore = ComputeTotalFitnessScore(this.Schedules);
        }
        
        public void AdvanceGeneration()
        {
            //List<Schedule> nextGenerationSchedules = new List<Schedule>(Generation.SIZE_OF_GENERATION);
            BreedWithFitnessPoportionateSelection();

        }

        public bool WillParentsBreed(int indexOfParent1, int indexOfParent2)
        {
            //double chance = (this.Schedules[indexOfParent1].FitnessScore + this.Schedules[indexOfParent2].FitnessScore) / 2;
            //chance e

            return true;

        }

        public Generation(List<Schedule> inSchedules)
        {
            this.schedules = new List<Schedule>(inSchedules);
        }

        public bool IsEmpty()
        {
            return this.schedules.Count <= 0;
        }

        public void BreedWithFitnessPoportionateSelection()
        {
            List<Schedule> currentGeneration = new List<Schedule>(this.Schedules); // ? a little confusing since currentGeneration isn't a generation object
            this.schedules = new List<Schedule>(Generation.SIZE_OF_GENERATION); // ? maybe redesign
            while (currentGeneration.Count > 0) // loop while there are still members in current generation // ? could optimze with just SIZE_OF_GENERATION and minus 2 but this is more scalable and reusable
            {
                // ? not sure if you're supposed to give the parents a chance to reproduce or not.
                // ? that should be handled just by selection?

                //// get next two parents // separate out into antoher function??
                int indexOfParent1 = this.BenRoutlette(currentGeneration);
                int indexOfParent2 = this.BenRoutlette(currentGeneration);


                while (indexOfParent1 == indexOfParent2) // makes sure we have two different indexes
                {
                    indexOfParent2 = this.BenRoutlette(currentGeneration);
                }


                // If parents are going to breed, pass their chidlren on to next generation, else pass parents on to next generation
                if (this.WillParentsBreed(indexOfParent1, indexOfParent2))
                {
                    // Add the two parents new children to the next generation
                    this.schedules.Add(new Schedule(currentGeneration[indexOfParent1], currentGeneration[indexOfParent2]));
                    this.schedules.Add(new Schedule(currentGeneration[indexOfParent2], currentGeneration[indexOfParent1]));
                }
                else // comment out this else for new GA ?
                {
                    this.schedules.Add(currentGeneration[indexOfParent1]);
                    this.schedules.Add(currentGeneration[indexOfParent2]);
                }

                // Remove the parents from the current pool
                if (indexOfParent1 > indexOfParent2) // this is to make sure removing one parent doesn't move the index of the second
                {
                    currentGeneration.RemoveAt(indexOfParent1);
                    currentGeneration.RemoveAt(indexOfParent2);
                }
                else
                {
                    currentGeneration.RemoveAt(indexOfParent2);
                    currentGeneration.RemoveAt(indexOfParent1);
                }
            }
        }


        // ? need to weight somewhere by one to avoid divide by zero if perfect population?
        /**************************************************************************\
        Method: BenRoutlette
        Description: Randomly selects an index with weight from fitness scores
        \**************************************************************************/
        public int BenRoutlette(List<Schedule> schedules)
        {
            double totalFitnessScoreWeight = (ComputeTotalFitnessScore(schedules)); // maybe add in one ? it avoids divide by zero // ? maybe make fitness score not shrink with population?

            double randomFloat = GA_Controller.GetRandomFloat() * totalFitnessScoreWeight;
            for (int i = 0; i < schedules.Count; i++) // ? current generation will shrink as more and more are moved to next generation 
            {

                randomFloat -= schedules[i].FitnessScore;
                if (randomFloat <= 0)
                {
                    return i;
                }
            }
            Console.WriteLine("that's not good..."); // ?
            return this.schedules.Count - 1; // ? This point should never be reached. roundoff error? ? it could fail on empty schedule
        }

        /**************************************************************************\
        Method: ComputeTotalFitnessScore
        Description: Computes the total fitness score of all schedules
        \**************************************************************************/
        public double ComputeTotalFitnessScore(List<Schedule> schedules)
        {
            double totalFitnessScore = 0;
            foreach (Schedule schedule in schedules)
            {
                totalFitnessScore += schedule.FitnessScore;
            }
            return totalFitnessScore;
        }

        // ? see if moving this to controller results in faster programs
        public void OrderByFitnessScore()
        {
            this.schedules = this.schedules.OrderByDescending(c => c.FitnessScore).ToList();
        }

        public Schedule GetMostFit()
        {
            OrderByFitnessScore();
            return this.Schedules[0];
        }
        public Schedule GetWorstFit()
        {
            OrderByFitnessScore();
            return this.Schedules[this.Schedules.Count-1];
        }

    }
}

















        ///**************************************************************************\
        //Method: AdvanceGeneration
        //Description: Handles crossing over of current generation to the next
        //             generation
        //\**************************************************************************/
        //public static void AdvanceGeneration()
        //{

        //    List<Schedule> nextGeneration = new List<Schedule>(GA_Controller.SIZE_OF_GENERATION);
        //    while (currentGeneration.Count > 0) // loop while there are still members in current generation // ? could optimze with just SIZE_OF_GENERATION and minus 2 but this is more scalable and reusable
        //    {
        //        // ? not sure if you're supposed to give the parents a chance to reproduce or not.
        //        // ? that should be handled just by selection?

        //        // get next two parents // separate out into antoher function??
        //        int indexOfParent1 = BenRoutlette();
        //        int indexOfParent2 = BenRoutlette();
        //        while (indexOfParent1 == indexOfParent2) // makes sure we have two different indexes
        //        {
        //            indexOfParent2 = BenRoutlette();
        //        }

        //        // If parents are going to breed, pass their chidlren on to next generation, else pass parents on to next generation
        //        if (WillParentsBreed(indexOfParent1, indexOfParent2))
        //        {
        //            // Add the two parents new children to the next generation
        //            nextGeneration.Add(new Schedule(currentGeneration[indexOfParent1], currentGeneration[indexOfParent2]));
        //            nextGeneration.Add(new Schedule(currentGeneration[indexOfParent2], currentGeneration[indexOfParent1]));                    
        //        }
        //        else
        //        {
        //            nextGeneration.Add(currentGeneration[indexOfParent1]);
        //            nextGeneration.Add(currentGeneration[indexOfParent2]);
        //        }

        //        // Remove the parents from the current pool
        //        if (indexOfParent1 > indexOfParent2) // this is to make sure removing one parent doesn't move the index of the second
        //        {
        //            currentGeneration.RemoveAt(indexOfParent1);
        //            currentGeneration.RemoveAt(indexOfParent2);
        //        }
        //        else
        //        {
        //            currentGeneration.RemoveAt(indexOfParent2);
        //            currentGeneration.RemoveAt(indexOfParent1);
        //        }

        //    }
            
        //    currentGeneration = nextGeneration; // Advance to the next generation
        //}
        //public static void AdvanceGeneration2()
        //{
            
        //}



        ///**************************************************************************\
        //Method: ComputeTotalFitnessScore
        //Description: Computes the total fitness score of all schedules
        //\**************************************************************************/
        //public static int ComputeTotalFitnessScore()
        //{
        //    int totalFitnessScore = 0;
        //    foreach (Schedule schedule in GA_Controller.currentGeneration)
        //    {
        //        totalFitnessScore += schedule.FitnessScore;
        //    }
        //    return totalFitnessScore;
        //}

        //public static int ComputeTotalFitnessScore(List<Schedule> schedules)
        //{
        //    int totalFitnessScore = 0;
        //    foreach (Schedule schedule in schedules)
        //    {
        //        totalFitnessScore += schedule.FitnessScore;
        //    }
        //    return totalFitnessScore;
        //}




        /**************************************************************************\
        Method: SaveMostFitSchedule
        Description: Saves the most fit schedule to file
        \**************************************************************************/
        public static void SaveMostFitSchedule()
        {
            // ? write
        }


        /**************************************************************************\
        Method: SaveGeneration
        Description: Saves the current generation to file
        \**************************************************************************/
        public static void SaveGeneration()
        {
            // ? write
        }

        public static void CheckSchedule(Schedule schedule) // ? for testing
        {
            Console.WriteLine("\n***********************************************\n");
            Console.WriteLine("How good is this Schedule?... Let's find out!!!");
            Console.WriteLine("\n************************************************\n");

            //Console.WriteLine("Printing Basic information on Schedule");
            //Console.WriteLine("**************************************");
            //Schedule.Display();
            //Console.WriteLine();

            Console.WriteLine("Number of Blocks: {0}", Schedule.NumberOfTimeSlotsAvailable);

            // Check for bad blocks
            int failingBlocks = 0;
            foreach(Block block in schedule.Blocks)
            {
                if(block.AreThereAnyNonOverlappingClasses)
                {
                    failingBlocks++;
                }
            }
            Console.WriteLine("Number of Blocks that do *NOT* have overlapping Classes: {0}", Schedule.NumberOfTimeSlotsAvailable - failingBlocks);
        }

        /**************************************************************************\
        Constructor: Default 
        Description: 
        \**************************************************************************/ 
        //GA_Controller()
        //{
        //}


        ///**************************************************************************\
        //Constructor: Default 
        //Description: 
        //\**************************************************************************/ 
        //GA_Controller(Class[] incomingSetClasses, int numClasses, int numExams)
        //{
        //    setClasses = new Class[numClasses];
        //    incomingSetClasses.CopyTo(setClasses, numClasses);

        //}

        //List<Schedule> generateChildren(Schedule schedule1, Schedule schedule2)
        //{

        //}


        //Schedule RouletCrossOver(Schedule schedule1, Schedule schedule2)
        //{

        //}


        //// ?
        //// need finish
        //public static Schedule generateRandomSchedule(List<Class> classes)
        //{
        //    Random rand = new Random();
        //    classes = classes.OrderBy(c => rand.Next()).Select(c => c.Model).ToList(); // randomly arrange classes



        //    Schedule schedule = new Schedule(classes);

        //}

        

        //// ?
        //// need finish
        //public static List<Schedule> generateRandomGeneration(List<Class> classes)
        //{
        //    List<Schedule> generation = new List<Schedule>(); // makes blank generation

        //    for (int i = 0; i < GENERATION_SIZE; i++)
        //    {
        //        generation.Add(generateRandomSchedule(classes));
        //    }

        //    return generation;
        //}

        ///**************************************************************************\
        //Method: Assign Fitness 
        //Description: Should take a chromosome as an input and output its fitness
        //             score.
        //\**************************************************************************/
        //float AssignFitness()
        //{
        //    Constraints.CheckSoftConstraints();
        //    Constraints.CheckHardConstraints();

        //    return 0.0f;
        //}


        /**************************************************************************\
        Method: Crossover 
        Description: Takes two chromosomes as an input and performs crossover on
                     the genes to create two offspring based on the crossover rate.
        \**************************************************************************/ 
        //void Crossover()
        //{
        //}


        /**************************************************************************\
        Method: Roulette 
        Description: Selects a chromosome from the population proportional to its
                     fitness score. This is used to select members from the
                     population to go on to the next generation. It does not
                     guarantee that the most fit chromosomes will be selected, but
                     it does give them a good chance of doing so.
        \**************************************************************************/ 
        //void Roulette()
        //{
        //}


        /**************************************************************************\
        Method: Mutate 
        Description: Creates a mutation in a chromosome depending on the mutation
                     rate.
        \**************************************************************************/ 
        //void Mutate()
        //{
        //}
    }
}




using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



// ? Although reproduction methods that are based on the use of two parents are more "biology inspired", some research[3][4] suggests that more than two "parents" generate higher quality chromosomes.


namespace FETP
{
    /**************************************************************************\
    Class: GA_Controller (Genetic Algorithm Controller)
    Description: Includes all of the primary functions needed for the genetic
                 algorithm and evolving the chromosomes to find a solution.
    \**************************************************************************/ 
    public static class GA_Controller
    {
        /**************************************************************************\
        GA_Controller - Data Constants
        \**************************************************************************/ 
        // const int GENERATION_SIZE = 500;
        //private const int SIZE_OF_GENERATION = 50; // ? big generations take a long time
        //private const int NUMBER_OF_GENERATIONS = 1000;

        private const float CROSSOVER_RATE = 0.7F;
        public const float MUTATION_RATE = 0.04F;
       

        /**************************************************************************\
        GA_Controller - Weights
        \**************************************************************************/
        public static int WEIGHT_OVERLAPPING_CLASSES = 50; // static makes it fuction almost as const ?



        //private List<Schedule> currentGeneration;
        // private static List<Schedule> currentGeneration;


        public static Stopwatch stopwatch = new Stopwatch(); // ? for testing purposes 


        /**************************************************************************\
        GA_Controller - Methods 
        \**************************************************************************/

        public static void BenAllStartRun()
        {
            SetupIntialFields();

            List<Schedule> allStars = new List<Schedule>();

            Stopwatch newStopwatch = new Stopwatch();
            newStopwatch.Start();


            //for (int i = 0; i < Generation.SIZE_OF_GENERATION; i++)
            //{
            //    Generation generation = new Generation(); // sets up intial generation
            //    Console.WriteLine("Starting GA: {0}", i + 1);
            //    for (int j = 0; j < Generation.NUMBER_OF_GENERATIONS; j++) // ? is i the same for all loops?
            //    {
            //        generation.AdvanceGeneration();
            //    }

            //    Console.WriteLine("Time to Execute GA {0}: {1}", i + 1, newStopwatch.Elapsed);
            //    //lock (benLock)
            //    //{
            //    allStars.Add(generation.GetMostFit());
            //    //}


            //}

            object benLock = new object();
            object benLock2 = new object();
            object benLock3 = new object();

            lock(benLock2)
            {
                Parallel.For(0, Generation.SIZE_OF_GENERATION, new ParallelOptions { MaxDegreeOfParallelism = Generation.BEN_ALL_STAR_THREAD_LIMIT }, index =>
                {
                    Generation generation;
                    lock (benLock)
                    {
                        generation = new Generation(); // sets up intial generation
                    }

                    Console.WriteLine("Starting GA: {0}", index + 1);

                    for (int i = 0; i < Generation.NUMBER_OF_GENERATIONS; i++) // ? is i the same for all loops?
                    {
                        generation.AdvanceGeneration();
                    }

                    Console.WriteLine("Time to Execute GA {0}: {1}", index + 1, newStopwatch.Elapsed);

                    allStars.Add(generation.GetMostFit());
                });
            }
            

            List<Schedule> betterAllStars = new List<Schedule>();
            //lock(benLock2)
            //{
            //    Parallel.For(0, Generation.SIZE_OF_GENERATION, new ParallelOptions { MaxDegreeOfParallelism = Generation.BEN_ALL_STAR_THREAD_LIMIT }, index =>
            //    {
            //        Generation generation;
            //        lock (benLock)
            //        {
            //            generation = new Generation(allStars); // sets up intial generation
            //        }

            //        for (int i = 0; i < Generation.NUMBER_OF_GENERATIONS; i++) // ? is i the same for all loops?
            //        {
            //            generation.AdvanceGeneration();
            //        }

            //        betterAllStars.Add(generation.GetMostFit());
            //    });
            //}
            

            //for(int i = 0; i < SIZE_OF_GENERATION; i++)
            //{
            //    Run();
            //    allStars.Add(currentGeneration[0]);
            //}

            // Do All Star run
            Console.WriteLine("Starting allstar run");
            Generation lastGen = new Generation(allStars);
            for (int i = 0; i < Generation.NUMBER_OF_GENERATIONS; i++) // ? is i the same for all loops?
            {
                lastGen.AdvanceGeneration();
            }

            lastGen.OrderByFitnessScore();

            foreach(Schedule sch in lastGen.Schedules)
            {
                CheckSchedule(sch); // ? could be that some groups have less overlapping classes even though more clean blocks?
            }



            //Console.WriteLine("Displaying worst fit schedule");
            //Console.WriteLine();
            //lastGen.GetWorstFit().DisplayBlocks();
            //Console.WriteLine("Displaying most fit schedule");
            //Console.WriteLine();


            //CheckSchedule(lastGen.GetMostFit());

            //Console.WriteLine("Displaying most fit schedules");
            //Console.WriteLine();
            //for (int i = 0; i < 5; i++)
            //{
            //    CheckSchedule(lastGen.Schedules[i]); // should already be sorted
            //}

            Console.WriteLine(Schedule.AllClasses.Count);
            int classnum = 0;
            foreach (Block block in lastGen.Schedules[0].Blocks)
            {
                classnum+= block.ClassesInBlock.Count;
            }
            Console.WriteLine(classnum);
        }

        
        /**************************************************************************\
        Method: Run
        Description: Basic Testing Driver for GA
        \**************************************************************************/
        public static void Run()
        {
            Console.WriteLine("Begining GA\n");

            // Get input
            SetupIntialFields();

            // Intialize First Generation
            stopwatch.Restart();

            Generation generation = new Generation();

            stopwatch.Stop();
            Console.WriteLine("Time to Create Seed Generation: {0}", stopwatch.Elapsed);
            stopwatch.Reset();

            // Run GA
            for (int i = 0; i < Generation.NUMBER_OF_GENERATIONS; i++)
            {
                stopwatch.Start();
                generation.AdvanceGeneration();
                stopwatch.Stop();
                Console.WriteLine("Time to Execute {0} generations: {1}", i + 1, stopwatch.Elapsed);
            }




            Console.WriteLine("Displaying worst fit schedule");
            Console.WriteLine();
            //generation.GetMostFit().DisplayBlocks();
            CheckSchedule(generation.GetWorstFit());

            Console.WriteLine("Displaying most fit schedules");
            Console.WriteLine();
            for(int i = 0; i < 5; i++)
            {
                CheckSchedule(generation.Schedules[i]); // should already be sorted
            }
            

            
            //currentGeneration.OrderByDescending(c => c.FitnessScore).ToList();

            //Console.WriteLine();
            //currentGeneration[0].DisplayBlocks();
            //CheckSchedule(currentGeneration[0]);
        
            








        //Console.WriteLine("Begining GA\n");

        //    // Get input
        //    SetupIntialFields();

        //    // Intialize First Generation
        //    stopwatch.Restart();

        //    IntializeSeedGeneration();

        //    stopwatch.Stop();
        //    Console.WriteLine("Time to Create Seed Generation: {0}", stopwatch.Elapsed);
        //    stopwatch.Reset();

        //    // Run GA
        //    RunGeneticAlgorithm();

        //    Console.WriteLine("Displaying most fit schedule");
        //    currentGeneration.OrderByDescending(c => c.FitnessScore).ToList();
            
        //    Console.WriteLine();
        //    currentGeneration[0].DisplayBlocks();
        //    CheckSchedule(currentGeneration[0]);
        }

        /// <summary> 
        /// Perform a divide by b
        ///      e.g a = 1, b = 2
        /// will return 0, since (1/2) = 0.5
        /// </summary>
        /// <returns>int value</returns>
        



        /**************************************************************************\
        Method: RunGeneticAlgorithm
        Description: Executtes the Genetic Algorithm. For the number of 
                     generations desired to go through, advances 
                     the generation
        \**************************************************************************/
        //public static void RunGeneticAlgorithm()
        //{
        //    for (int i = 0; i < NUMBER_OF_GENERATIONS; i++)
        //    {
        //        stopwatch.Start();
        //        AdvanceGeneration();
        //        stopwatch.Stop();
        //        Console.WriteLine("Time to Execute {0} generations: {1}", i + 1, stopwatch.Elapsed);
        //    }
        //}
        //public static void RunGeneticAlgorithm2()
        //{
        //    for (int i = 0; i < NUMBER_OF_GENERATIONS; i++)
        //    {
        //        stopwatch.Start();
                
        //        stopwatch.Stop();
        //        Console.WriteLine("Time to Execute {0} generations: {1}", i + 1, stopwatch.Elapsed);
        //    }
        //}


        /**************************************************************************\
        Method: WillParentsBreed
        Description: Determines whether or not two parents will breed
        \**************************************************************************/
        public static bool WillParentsBreed(int indexOfParent1, int indexOfParent2)
        {
            return true; // ? Rewrite Victor
        }


        /**************************************************************************\
        Method: IntializeSeedGeneration
        Description: Creates the first generation for GA
        \**************************************************************************/
        //public static void IntializeSeedGeneration()
        //{
        //    // Intialize the current generation
        //    GA_Controller.currentGeneration = new List<Schedule>(SIZE_OF_GENERATION);

        //    // create seed generation
        //    for (int i = 0; i < GA_Controller.SIZE_OF_GENERATION; i++)
        //    {
        //        GA_Controller.currentGeneration.Add(new Schedule());
        //    }
        //}


        //// ? need to weight somewhere by one to avoid divide by zero if perfect population?
        ///**************************************************************************\
        //Method: BenRoutlette
        //Description: Randomly selects an index with weight from fitness scores
        //\**************************************************************************/
        //public static int BenRoutlette()
        //{
        //    int totalFitnessScoreWeight = (ComputeTotalFitnessScore()); // maybe add in one ? it avoids divide by zero

        //    double randomFloat = GetRandomFloat() * totalFitnessScoreWeight;

        //    for (int i = 0; i < GA_Controller.currentGeneration.Count; i++) // ? current generation will shrink as more and more are moved to next generation 
        //    {
        //        randomFloat -= currentGeneration[i].FitnessScore;
        //        if (randomFloat <= 0)
        //        {
        //            return i;
        //        }
        //    }
        //    return GA_Controller.currentGeneration.Count - 1; // ? This point should never be reached. roundoff error?
        //}
        //public static int BenRoutlette(List<Schedule> schedules)
        //{
        //    int totalFitnessScoreWeight = (ComputeTotalFitnessScore()); // maybe add in one ? it avoids divide by zero

        //    double randomFloat = GetRandomFloat() * totalFitnessScoreWeight;

        //    for (int i = 0; i < GA_Controller.currentGeneration.Count; i++) // ? current generation will shrink as more and more are moved to next generation 
        //    {
        //        randomFloat -= currentGeneration[i].FitnessScore;
        //        if (randomFloat <= 0)
        //        {
        //            return i;
        //        }
        //    }
        //    return GA_Controller.currentGeneration.Count - 1; // ? This point should never be reached. roundoff error?
        //}

		
                Console.WriteLine("3. Test Basic GA");
                Console.WriteLine("4. Test Ben's Allstar GA    <---- will devour CPU like ice cream on a hot day"); // ? crashes every now and then. theres a bug somewhere...
                
        
		else if (input == "3") // GA 
                {
                    //while(true)
                    GA_Controller.Run();
                }
                else if (input == "4")
                {
                    // while(true)
                    GA_Controller.BenAllStartRun();
                }

				
            this.PigeonHoleClasses(Schedule.AllClasses.OrderBy(c => GA_Controller.GetRandomInt()).ToList()); // sort in randomly order classes

			 // only runs during one generation. maybe move ?
        //// takes in a list of classes and coalesces them into a list of blocks of classes
        /**************************************************************************\
        Method: PigeonHoleClasses
        Description: Puts classes in blocks sequentially. 
                     Used in random schedule creation
        \**************************************************************************/
        private void PigeonHoleClasses(List<Class> classes) // ? I LOVE PIGEON HOLE
        {
            
            foreach (Class cl in classes)
            {
                int i = GA_Controller.GetRandomInt(this.Blocks.Count);

                // maybe check for empty blocks ?
                this.blocks[i].addClass(cl);

                //if (i < Schedule.NumberOfTimeSlotsAvailable - 1) // ? clean up
                //{
                //    i++;
                //}
                //else
                //{
                //    i = 0;
                //}
            }
        }

		
        /**************************************************************************\
        Method: WillMutate
        Description: Deteremines whether a mutation should occur
        \**************************************************************************/
        private bool WillMutate()
        {
            bool willItMutate = false;
            float randFloatBetween01 = FETP_Controller.RandomFloatBetween01();

            if (randFloatBetween01 < GA_Controller.MUTATION_RATE)
            {
                willItMutate = true;
            }

            return willItMutate;
        }


        /**************************************************************************\
        Method: Mutate
        Description: Mutates a scheudle
                     currently picks two random blocks, picks midpoints in those
                     blocks classes, then cuts the classes at that point, then
                     swaps them
        \**************************************************************************/
        public void Mutate()
        {
            Random rnd = new Random();

            // select two random blocks to combine
            int blockIndex1 = rnd.Next(0, this.blocks.Count); // ? this makes it possible to not mutate with 0? maybe. over weigting chance to not mutate?
            int blockIndex2 = rnd.Next(0, this.blocks.Count);

            // select a mid point in classes to swap from
            int midPointInClasses1 = rnd.Next(0, this.blocks[blockIndex1].ClassesInBlock.Count);
            int midPointInClasses2 = rnd.Next(0, this.blocks[blockIndex2].ClassesInBlock.Count);

            // swap parts of classes
            List<Class> tempClasses1 = blocks[blockIndex1].ClassesInBlock.GetRange(0, blocks[blockIndex1].ClassesInBlock.Count); // gets the objects from the beginning to index

            // ? make more readable
            blocks[blockIndex1].ClassesInBlock.RemoveRange(0, blocks[blockIndex1].ClassesInBlock.Count);
            blocks[blockIndex1].ClassesInBlock.AddRange(blocks[blockIndex2].ClassesInBlock.GetRange(0, blocks[blockIndex2].ClassesInBlock.Count)); // adds the range from the second class to block 1 // maybe not right to get front half from both ???
            blocks[blockIndex2].ClassesInBlock.RemoveRange(0, blocks[blockIndex2].ClassesInBlock.Count);
            blocks[blockIndex2].ClassesInBlock.AddRange(tempClasses1);
        }


        /**************************************************************************\
        Method: AttemptMutate
        Description: Attempts to mutate a scheudle. Runs a test to see if it
                     will mutate. If so, it mutates the schedule.                
        \**************************************************************************/
        public bool AttemptMutate()
        {
            bool didItMutate = false;
            if (this.WillMutate()) 
            {
                this.Mutate();
                didItMutate = true;
            }
            return didItMutate;
        }


		 // ? call twice for keeeeds. swap postions of parents
        /**************************************************************************\
        Constructor: Schedule Combining Constructor
        Description: Creates a schedule off parent schedules. I alternates 
                     taking blocks from each parent.
        Note: for two kids, call constructor twice with parent 
              schedules in different spots 
        \**************************************************************************/
        public Schedule(Schedule schedule1, Schedule schedule2)
        {
            SetUpBlocks();

            // int blockCount = Schedule.NumberOfTimeSlotsAvailable;
            for (int i = 0; i < Schedule.NumberOfTimeSlotsAvailable; i++) // maybe swap just whole halves
            {
                if (i % 2 == 0)
                {
                    this.blocks[i] = schedule1.Blocks[i];
                }
                else
                {
                    this.blocks[i] = schedule2.Blocks[i];
                }
            }


            //this.AttemptMutate(); // ? break up for cohesion

            // don't need randomness ?
        }

		   // creates a random schedule
        // maybe makes list of all classes static
        /**************************************************************************\
        Constructor: Random Constructor
        Description: Creates a random schedule off the incoming list of classes
        \**************************************************************************/
        public Schedule() // ? possibly make classes static. it would make it faster
        {
            

        }